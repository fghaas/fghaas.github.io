<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>xahteiwi.eu - systemd</title><link href="https://xahteiwi.eu/" rel="alternate"></link><link href="https://xahteiwi.eu/feeds/tag/systemd.atom.xml" rel="self"></link><id>https://xahteiwi.eu/</id><updated>2024-12-07T09:00:00+00:00</updated><entry><title>Exploding memory usage in Django/uWSGI containers</title><link href="https://xahteiwi.eu/resources/hints-and-kinks/max-fd/" rel="alternate"></link><published>2024-12-07T09:00:00+00:00</published><updated>2024-12-07T09:00:00+00:00</updated><author><name>Florian Haas</name></author><id>tag:xahteiwi.eu,2024-12-07:/resources/hints-and-kinks/max-fd/</id><summary type="html">&lt;p&gt;We recently came across an interesting problem at work while migrating from one flavor of Kubernetes to another. It&amp;rsquo;s sufficiently obscure to merit a brief write-up for reference.&lt;/p&gt;</summary><content type="html">&lt;p&gt;When running &lt;a href="https://openedx.org/"&gt;Open edX&lt;/a&gt; on &lt;a href="https://kubernetes.io"&gt;Kubernetes&lt;/a&gt; clusters, one of its &lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/"&gt;Pods&lt;/a&gt; is the &lt;code&gt;lms&lt;/code&gt; Pod, which runs the core of the Open edX Learning Management System (&lt;a href="https://github.com/openedx/edx-platform/tree/master/lms"&gt;LMS&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;This is a relatively complex &lt;a href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; application, which runs in the Pod’s sole container.
Said Django application is being launched with &lt;a href="https://uwsgi-docs.readthedocs.io/"&gt;uWSGI&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;At work, we had previously run this platform on Kubernetes clusters managed with &lt;a href="https://docs.openstack.org/magnum/"&gt;OpenStack Magnum&lt;/a&gt;, and were in the process of migrating to &lt;a href="https://gardener.cloud/"&gt;Gardener&lt;/a&gt;.
Apart from the fact that we were upgrading to a newer Kubernetes release, this also meant that the base operating system of our Kubernetes worker nodes changed from &lt;a href="https://fedoraproject.org/coreos/"&gt;Fedora CoreOS&lt;/a&gt; to &lt;a href="https://github.com/gardenlinux/gardenlinux"&gt;Garden Linux&lt;/a&gt; (which is effectively a Kubernetes-optimised Debian).
The virtualisation platform underpinning the Kubernetes cluster remained the same (&lt;a href="https://docs.openstack.org/"&gt;OpenStack&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Mid-migration, we suddenly noticed that our cluster was &lt;a href="https://en.wikipedia.org/wiki/Out_of_memory#Recovery"&gt;oom-killing&lt;/a&gt; our &lt;code&gt;lms&lt;/code&gt; pods.
Now this shouldn’t happen, for the following reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Normally, Kubernetes only kills a Pod for excessive memory usage when a &lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource/"&gt;memory limit&lt;/a&gt; is set on that Pod, which wasn’t the case.&lt;/li&gt;
&lt;li&gt;Otherwise (that is, with no memory limit set), Pods get killed only by the “regular” kernel oom-killer, and that should only happen when the Pod is grossly misconfigured — that is, its actual memory usage far exceeds its configured &lt;a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits"&gt;memory request&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We quickly found out (via &lt;code&gt;kubectl top pod&lt;/code&gt;) that we were dealing with the latter of these two: our &lt;code&gt;lms&lt;/code&gt; Pod was consuming a whopping 8 GiB of memory when running on the Gardener-managed cluster — nearly 4 times the memory request of 2 GiB.&lt;/p&gt;
&lt;p&gt;This had us scratching our heads, for on the Magnum-managed cluster it was previously running on, that same pod had typically consumed only 80-120 MiB of memory (with occasional spikes).
Thus, we were dealing with baseline memory usage that had suddenly increased by two orders of magnitude.&lt;/p&gt;
&lt;p&gt;Now to explain this memory usage jump, you’ll need this background information:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;corerouter&lt;/code&gt; plugin in uWSGI maintains an array of file descriptor references.&lt;/li&gt;
&lt;li&gt;The size of this array, and with it its memory usage, is a multiple of the value set for uWSGI’s &lt;code&gt;max-fd&lt;/code&gt; configuration option.&lt;sup id="fnref:corerouter"&gt;&lt;a class="footnote-ref" href="#fn:corerouter"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;max-fd&lt;/code&gt; has not been set in the uWSGI configuration, its default is the maximum number of open file handles allowed for the process per the system-wide configuration.&lt;/li&gt;
&lt;li&gt;Said default can be defined by the &lt;code&gt;nofiles&lt;/code&gt; &lt;a href="https://www.man7.org/linux/man-pages/man5/limits.conf.5.html"&gt;ulimit&lt;/a&gt;, or a &lt;a href="https://wiki.archlinux.org/title/Cgroups"&gt;cgroups&lt;/a&gt; restriction.
   A cgroups restriction is also what systemd uses to implement &lt;a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#Process%20Properties"&gt;the &lt;code&gt;LimitNOFILE&lt;/code&gt; option&lt;/a&gt;, which can be set on any systemd unit.&lt;sup id="fnref:man-outdated"&gt;&lt;a class="footnote-ref" href="#fn:man-outdated"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;If neither the ulimit nor a cgroups restriction is in place, &lt;a href="https://www.kernel.org/doc/Documentation/sysctl/fs.txt"&gt;the &lt;code&gt;fs.nr_open&lt;/code&gt; sysctl&lt;/a&gt;, if set, acts as a backstop. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Prior to release 256, systemd effectively &lt;a href="https://github.com/systemd/systemd/pull/29322"&gt;bumped the default&lt;/a&gt; for &lt;code&gt;LimitNOFILE&lt;/code&gt; from 1048576 (2²⁰) to &lt;code&gt;infinity&lt;/code&gt;, which meant that rather than setting its own cgroups limit, it would rely on &lt;code&gt;fs.nr_open&lt;/code&gt;.
And &lt;em&gt;that&lt;/em&gt; value was recently upped in some distributions to 1073741824 (2³⁰) — an increase by a factor of 2¹⁰ or 1024 over the previously applicable value.&lt;/p&gt;
&lt;p&gt;This change was also applied on Debian (which Garden Linux is based on), and it was even &lt;a href="https://lists.debian.org/debian-devel/2024/06/msg00041.html"&gt;discussed on the Debian mailing list&lt;/a&gt; — where ironically, concerns about raising this limit were pre-emptively quashed with the assertion that file descriptors are such an “extremely cheap resource” that it does not hurt to allow absurdly high numbers of them.&lt;/p&gt;
&lt;p&gt;In the uWSGI case, however, this had the somewhat devastating effect of increasing memory usage to insane levels.&lt;/p&gt;
&lt;p&gt;To their credit, the Garden Linux developers identified this flaw (which, to my knowledge was baked into their version 1592.2), and &lt;a href="https://github.com/gardenlinux/gardenlinux/pull/2442"&gt;fixed it&lt;/a&gt; in version 1592.3.
Still, to insulate ourselves from further such issues, we have opted to &lt;a href="https://uwsgi-docs.readthedocs.io/en/latest/Configuration.html"&gt;reconfigure our systems&lt;/a&gt; to run uWSGI with an explicitly defined &lt;code&gt;max-fd&lt;/code&gt; option, set to the prior system-wide default of 1048576 (although setting it to something as low as 1024 would &lt;em&gt;probably&lt;/em&gt; work too). &lt;/p&gt;
&lt;h3&gt;Acknowledgements&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/lotharbach"&gt;Lothar Bach&lt;/a&gt;, &lt;a href="https://github.com/polarathene"&gt;Brennan Kinney&lt;/a&gt;, &lt;a href="https://github.com/pkdevpl"&gt;Piotr Kucułyma&lt;/a&gt;, &lt;a href="https://github.com/NamrataSitlani"&gt;Namrata Sitlani&lt;/a&gt;, and &lt;a href="https://github.com/mrtmm"&gt;Maari Tamm&lt;/a&gt; all contributed to the findings discussed in this article.&lt;sup id="fnref:order"&gt;&lt;a class="footnote-ref" href="#fn:order"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:corerouter"&gt;
&lt;p&gt;See &lt;a href="https://github.com/unbit/uwsgi/blob/master/plugins/corerouter/corerouter.c#L705"&gt;the source&lt;/a&gt;, which at the time of writing reads:
  &lt;code&gt;ucr-&amp;gt;cr_table = uwsgi_malloc(sizeof(struct corerouter_session *) * uwsgi.max_fd);&lt;/code&gt; &lt;a class="footnote-backref" href="#fnref:corerouter" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:man-outdated"&gt;
&lt;p&gt;As far as I can tell, at the time of writing the table captioned “Resource limit directives” in the &lt;code&gt;systemd.exec&lt;/code&gt; man page is outdated and incorrect as far as &lt;code&gt;LimitNOFILE&lt;/code&gt;’s default is concerned, and also the “Don’t use” admonition seems misguided at this point. &lt;a class="footnote-backref" href="#fnref:man-outdated" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:order"&gt;
&lt;p&gt;I’ve listed these individuals in alphabetical order by surname. &lt;a class="footnote-backref" href="#fnref:order" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="hints-and-kinks"></category><category term="Kubernetes"></category><category term="Django"></category><category term="Containers"></category><category term="systemd"></category></entry><entry><title>Rootless Podman, systemd, and Docker Compose files</title><link href="https://xahteiwi.eu/resources/hints-and-kinks/rootless-podman-docker-compose/" rel="alternate"></link><published>2023-10-26T21:00:00+00:00</published><updated>2023-10-26T21:00:00+00:00</updated><author><name>Florian Haas</name></author><id>tag:xahteiwi.eu,2023-10-26:/resources/hints-and-kinks/rootless-podman-docker-compose/</id><summary type="html">&lt;p&gt;How I run containers for my Home Assistant deployment&lt;/p&gt;</summary><content type="html">&lt;p&gt;This is a summary of how I run a set of Docker (actually, &lt;a href="https://podman.io/"&gt;Podman&lt;/a&gt;) containers for my &lt;a href="https://www.home-assistant.io/"&gt;Home Assistant&lt;/a&gt; setup on a &lt;a href="https://en.wikipedia.org/wiki/Raspberry_Pi"&gt;Raspberry Pi&lt;/a&gt;. It works reasonably well for me, so I am sharing it here in the hope that it is useful to others.&lt;/p&gt;
&lt;h2&gt;The stage&lt;/h2&gt;
&lt;p&gt;I run my Home Assistant environment on a &lt;a href="https://www.raspberrypi.com/products/raspberry-pi-4-model-b/"&gt;Raspberry Pi 4B&lt;/a&gt; running, currently, &lt;a href="https://releases.ubuntu.com/lunar/"&gt;Ubuntu 23.04 Lunar Lobster&lt;/a&gt;.
In total, that little machine runs five containers, out of which 3 are related to Home Assistant:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One is for Home Assistant itself,&lt;/li&gt;
&lt;li&gt;one is for running the &lt;a href="https://mosquitto.org/"&gt;Mosquitto&lt;/a&gt; MQTT broker,&lt;/li&gt;
&lt;li&gt;and one is for running &lt;a href="https://github.com/johanmeijer/grott"&gt;Grott&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For all these services, the respective developer communities do not only maintain official Docker images, but also supported or at least recommended &lt;a href="https://docs.docker.com/compose/"&gt;Docker Compose&lt;/a&gt; configurations.&lt;/p&gt;
&lt;p&gt;I wanted a way to make the most of those available configurations, so as not to reinvent too many wheels.&lt;/p&gt;
&lt;h2&gt;How I manage containers&lt;/h2&gt;
&lt;p&gt;I prefer my containers to run &lt;a href="https://www.redhat.com/sysadmin/rootless-podman-makes-sense"&gt;in the context of users other than &lt;code&gt;root&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Per-container system users&lt;/h3&gt;
&lt;p&gt;This means that I create a dedicated user for each container.
What’s important is that in order to be able to use systemd user services later, I enable &lt;a href="https://www.freedesktop.org/software/systemd/man/latest/loginctl.html#enable-linger%20USER%E2%80%A6"&gt;lingering&lt;/a&gt; for each user account.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;-i
&lt;span class="gp"&gt;# &lt;/span&gt;useradd&lt;span class="w"&gt; &lt;/span&gt;homeassistant
&lt;span class="gp"&gt;# &lt;/span&gt;adduser&lt;span class="w"&gt; &lt;/span&gt;homeassistant&lt;span class="w"&gt; &lt;/span&gt;bluetooth
&lt;span class="gp"&gt;# &lt;/span&gt;loginctl&lt;span class="w"&gt; &lt;/span&gt;enable-linger&lt;span class="w"&gt; &lt;/span&gt;homeassistant
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to &lt;em&gt;actually&lt;/em&gt; enable lingering for the affected users, one must apparently reboot the machine after this change.&lt;/p&gt;
&lt;p&gt;(I’ll get back to why I add the &lt;code&gt;homeassistant&lt;/code&gt; user to the &lt;code&gt;bluetooth&lt;/code&gt; group in a moment.)&lt;/p&gt;
&lt;h3&gt;Podman&lt;/h3&gt;
&lt;p&gt;I also don’t very much like the daemon-driven approach from Docker proper, so I tend to prefer &lt;code&gt;podman&lt;/code&gt; as my container manager on a small system like the Raspberry Pi.&lt;/p&gt;
&lt;p&gt;Podman tends to not be &lt;em&gt;particularly&lt;/em&gt; well covered in the documentation of the projects I work with, but that is not much of an issue:
I can combine Podman with a compatibility layer, &lt;code&gt;podman-compose&lt;/code&gt;, so that although I am actually &lt;em&gt;using&lt;/em&gt; Podman, I can configure my containers with an unchanged YAML configuration originally written for Docker Compose.&lt;/p&gt;
&lt;p&gt;Here’s how I can install the necessary packages on my Raspberry Pi:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="gp"&gt;# &lt;/span&gt;apt&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;podman&lt;span class="w"&gt; &lt;/span&gt;podman-compose
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next, I create the necessary Docker Compose configurations in the home directory of a user created to run that container.&lt;/p&gt;
&lt;p&gt;For example, the &lt;code&gt;/home/homeassistant&lt;/code&gt; directory, owned by the user &lt;code&gt;homeassistant&lt;/code&gt;, contains this &lt;code&gt;docker-compose.yaml&lt;/code&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# /home/homeassistant/docker-compose.yaml&lt;/span&gt;
&lt;span class="nn"&gt;---&lt;/span&gt;
&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;'3'&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;homeassistant&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;container_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;homeassistant&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"ghcr.io/home-assistant/home-assistant:stable"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;/etc/localtime:/etc/localtime:ro&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;# Replace this volume mapping with wherever&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;# you want to put your Home Assistant configuration&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;/home/homeassistant/.config/homeassistant:/config&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;/run/dbus:/run/dbus:ro&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;8123:8123&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;always&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;environment &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p p-Indicator"&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can of course create a more elaborate configuration as you please.&lt;/p&gt;
&lt;p&gt;Once this is set, I can manually fire up my container as a non-&lt;code&gt;root&lt;/code&gt; user, using Podman, like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;id
&lt;span class="go"&gt;uid=1003(homeassistant) gid=1003(homeassistant) groups=1003(homeassistant),124(bluetooth)&lt;/span&gt;

&lt;span class="gp"&gt;$ &lt;/span&gt;podman-compose&lt;span class="w"&gt; &lt;/span&gt;up
&lt;span class="go"&gt;['podman', '--version', '']&lt;/span&gt;
&lt;span class="go"&gt;using podman version: 4.3.1&lt;/span&gt;
&lt;span class="go"&gt;** excluding:  set()&lt;/span&gt;
&lt;span class="go"&gt;['podman', 'network', 'exists', 'homeassistant_default']&lt;/span&gt;
&lt;span class="go"&gt;podman create --name=homeassistant --label io.podman.compose.config-hash=123 --label io.podman.compose.project=homeassistant --label io.podman.compose.version=0.0.1 --label com.docker.compose.project=homeassistant --label com.docker.compo&lt;/span&gt;
&lt;span class="go"&gt;se.project.working_dir=/home/homeassistant --label com.docker.compose.project.config_files=docker-compose.yaml --label com.docker.compose.container-number=1 --label com.docker.compose.service=homeassistant -v /home/homeassistant/.config/h&lt;/span&gt;
&lt;span class="go"&gt;omeassistant:/config -v /usr/share/zoneinfo/Etc/UTC:/etc/localtime:ro -v /run/dbus:/run/dbus:ro --net homeassistant_default --network-alias homeassistant -p 8123:8123 --restart always ghcr.io/home-assistant/home-assistant:stable&lt;/span&gt;
&lt;span class="go"&gt;[...]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Systemd&lt;/h3&gt;
&lt;p&gt;Once I am satisfied that my container comes up just fine, the next step is managing it with &lt;code&gt;systemd&lt;/code&gt; in &lt;a href="https://wiki.archlinux.org/title/systemd/User"&gt;user mode&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To do that, I need to create a config directory for &lt;code&gt;systemd&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;mkdir&lt;span class="w"&gt; &lt;/span&gt;-p&lt;span class="w"&gt; &lt;/span&gt;~/.config/systemd/user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;… and create a single file in there, which I name &lt;code&gt;podman-compose.service&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;[Unit]&lt;/span&gt;
&lt;span class="na"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;Podman via podman-compose&lt;/span&gt;
&lt;span class="na"&gt;Wants&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;network-online.target&lt;/span&gt;
&lt;span class="na"&gt;After&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;network-online.target&lt;/span&gt;
&lt;span class="na"&gt;RequiresMountsFor&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;%t/containers&lt;/span&gt;

&lt;span class="k"&gt;[Service]&lt;/span&gt;
&lt;span class="na"&gt;Environment&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;PODMAN_SYSTEMD_UNIT=%n&lt;/span&gt;
&lt;span class="na"&gt;Environment&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;PODMAN_USERNS=keep-id&lt;/span&gt;
&lt;span class="na"&gt;Restart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;always&lt;/span&gt;
&lt;span class="na"&gt;TimeoutStartSec&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;60&lt;/span&gt;
&lt;span class="na"&gt;TimeoutStopSec&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;60&lt;/span&gt;
&lt;span class="na"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/usr/bin/podman-compose up --remove-orphans&lt;/span&gt;
&lt;span class="na"&gt;ExecStop&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/usr/bin/podman-compose stop&lt;/span&gt;
&lt;span class="na"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;simple&lt;/span&gt;
&lt;span class="na"&gt;WorkingDirectory&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;%h&lt;/span&gt;

&lt;span class="k"&gt;[Install]&lt;/span&gt;
&lt;span class="na"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;default.target&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that many other tutorials about running &lt;code&gt;docker-compose&lt;/code&gt; or &lt;code&gt;podman-compose&lt;/code&gt; from systemd recommend you set &lt;code&gt;Type=oneshot&lt;/code&gt; instead, and add the &lt;code&gt;-d&lt;/code&gt; option to the &lt;code&gt;ExecStart&lt;/code&gt; command.&lt;/p&gt;
&lt;p&gt;I think using the &lt;code&gt;simple&lt;/code&gt; type and &lt;em&gt;omitting&lt;/em&gt; the &lt;code&gt;-d&lt;/code&gt; option is the better idea, because in doing so,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I see the latest log lines from the container in &lt;code&gt;systemctl --user status podman-compose&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;I can access the full log with &lt;code&gt;journalctl --user -u podman-compose&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;I get more reliable output overall from &lt;code&gt;systemctl --user status podman-compose&lt;/code&gt;, because rather than only reflecting whether &lt;em&gt;starting&lt;/em&gt; the container was successful, it tells me whether it is still &lt;em&gt;running&lt;/em&gt; at the time I check.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For more details on what the various &lt;code&gt;%&lt;/code&gt;-prefixed &lt;em&gt;specifiers&lt;/em&gt; mean, see &lt;a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#Specifiers"&gt;the relevant section in the systemd documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Environment=PODMAN_USERNS=keep-id&lt;/code&gt; entry is somewhat crucial in a Home Assistant configuration.
This, in combination with adding the &lt;code&gt;homeassistant&lt;/code&gt; user to the &lt;code&gt;bluetooth&lt;/code&gt; group and bind-mounting the &lt;code&gt;/run/dbus&lt;/code&gt; directory, enables me to use the Raspberry Pi’s Bluetooth controller from the rootless container.&lt;sup id="fnref:fattire"&gt;&lt;a class="footnote-ref" href="#fn:fattire"&gt;1&lt;/a&gt;&lt;/sup&gt;
That comes in handy for Home Assistant integrations for sensor devices using &lt;a href="https://en.wikipedia.org/wiki/Bluetooth_Low_Energy"&gt;BLE&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Then, running&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;export&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;XDG_RUNTIME_DIR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/run/user/&lt;span class="nv"&gt;$UID&lt;/span&gt;
&lt;span class="gp"&gt;$ &lt;/span&gt;systemctl&lt;span class="w"&gt; &lt;/span&gt;--user&lt;span class="w"&gt; &lt;/span&gt;daemon-reload
&lt;span class="gp"&gt;$ &lt;/span&gt;systemctl&lt;span class="w"&gt; &lt;/span&gt;--user&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="w"&gt; &lt;/span&gt;podman-compose
&lt;span class="gp"&gt;$ &lt;/span&gt;systemctl&lt;span class="w"&gt; &lt;/span&gt;--user&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;enable&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;podman-compose
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;starts my container, and also brings it up (under the non-&lt;code&gt;root&lt;/code&gt; user account) every time the system boots.&lt;/p&gt;
&lt;h2&gt;In summary&lt;/h2&gt;
&lt;p&gt;What’s nice about this whole approach is that for all of my container-based services &lt;strong&gt;the configuration is exactly identical,&lt;/strong&gt; except for one thing that differs from service to service: the &lt;code&gt;docker-compose.yaml&lt;/code&gt; file.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:fattire"&gt;
&lt;p&gt;Thanks to GitHub user &lt;a href="https://github.com/fat-tire"&gt;“Fattire”&lt;/a&gt; for &lt;a href="https://github.com/onedr0p/containers/issues/68#issuecomment-1250035050"&gt;an immensely useful GitHub comment&lt;/a&gt; on this subject! &lt;a class="footnote-backref" href="#fnref:fattire" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="hints-and-kinks"></category><category term="Containers"></category><category term="Docker"></category><category term="Podman"></category><category term="systemd"></category></entry></feed>